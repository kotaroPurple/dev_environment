# 要求仕様

## 背景と目的
- 本プロジェクトはチーム共通で利用できるオンライン時系列処理ライブラリを提供する
- PyTorch の `Dataset`/`DataLoader` の思想を参考にしつつ、組み込み環境でも成立する逐次ブロック処理の設計を整える
- データ読込と前処理の共通化により開発者は処理ロジックの開発に集中できる
- 抽象化された入出力構造と処理フレームワークを提供し、車輪の再発明を避ける

## スコープ
- Python を用いたオンライン時系列データ処理ライブラリ
- PyTorch の `Dataset`/`DataLoader` を参考にしたデータ供給インターフェースとパイプライン制御 (単一スレッド、逐次処理)
- データの取得、保持、配布、および処理パイプライン制御
- uv と ruff を用いた開発環境構築および品質管理

## 想定利用者
- プロダクト横断のデータ分析・機械学習チームメンバ
- 時系列データを扱うプロジェクトのアプリケーション開発者

## 前提・制約
- プロジェクト環境は uv を利用する Python プロジェクトとする
- 依存パッケージは `uv add` を用いて追加する
- コード品質は ruff により担保し、ルールは `E`, `F`, `W`, `I` を適用する
- スタイル: 1 行 100 文字以下、関数間は 2 行の空行を確保する

## 用語定義
- ブロック: オンライン処理で逐次的に読み出されるデータ単位
- データコンテナ: dataclass または同等の構造で表現される入出力データ構造
- ストリームデータセット: PyTorch の `Dataset` コンセプトを拡張し、逐次アクセスや状態管理に対応したデータ供給オブジェクト
- データローダ: ストリームデータセットからブロックを取り出し処理パイプラインへ渡す制御オブジェクト (単一ワーカー、同期実行)
- 処理ノード: 入力データを受け取り出力を生成する個別処理
- パイプライン: 処理ノードを順序づけて構成した全体処理流れ

## 機能要求
- FR-1: 入力データはサンプリング周波数とタイムスタンプを保持する
- FR-2: データコンテナは多次元データを扱える構造体を提供する
- FR-3: データローダはブロック単位でデータを提供し、逐次処理の開始・停止・復帰を制御できる
- FR-4: 各ブロックの処理完了後に次ブロックの読み出しを開始する直列フローを保証する
- FR-5: データは push 操作で蓄積でき、複数処理ノードに共有できる
- FR-6: 処理ノードは必要な入力データ型を宣言し、フレームワークが依存関係を解決する
- FR-7: 処理ノードの実行順序は開発者が定義できる
- FR-8: 1 つの処理の結果を複数処理が参照できるようにする
- FR-9: オンライン処理としてブロック単位で逐次データを取り込み処理する
- FR-10: パイプラインの途中結果をログまたは外部出力へ送出できる
- FR-11: 処理ノード間で型安全な入出力を保証する
- FR-12: エラー発生時にパイプラインを停止または継続する制御が可能である

## 非機能要求
- NFR-1: 逐次処理でリアルタイム性を阻害しない設計とする
- NFR-2: 1 ブロック処理の開始から完了までの遅延が許容範囲内に収まること (単一スレッド)
- NFR-3: 処理ノードやデータコンテナ、データセット実装を容易に拡張できる API 安定性を維持する
- NFR-4: メモリ使用量を制御し、組み込み環境でも動作する軽量な実装とする
- NFR-5: Ruff およびテストにより品質を継続的に確認できる
- NFR-6: ドキュメントとサンプルコードにより新規利用者が短時間で導入できる
- NFR-7: パイプライン定義の変更が既存処理に影響を与えないようバージョニングを行う

## インターフェース要求
- データコンテナは dataclass に準拠した属性アクセスを提供する
- ストリームデータセットおよびデータローダは PyTorch の API を想起させるメソッドシグネチャを提供しつつ、組み込み向けに同期的に動作する
- 処理ノードは抽象基底クラスまたはプロトコルで定義されたインターフェースを実装する
- パイプライン定義は設定ファイルまたはコードによる宣言的な API を提供する

## 運用・保守要求
- パイプラインの状態や処理結果を監視しやすいログ出力を備える
- 依存ライブラリの更新手順を文書化する
- サンプルパイプラインで基本動作を検証できる

## リスクと対応
- データ形式の多様性: 抽象化レイヤを設け実装例を充実させる
- 処理順序の複雑化: 可視化ツールやデバッグ用 API を用意する
- リアルタイム性の劣化: 遅延を測定するメトリクスを提供しボトルネックを特定する
- ブロック処理の遅延: プロファイル計測を行い、計算量を最適化する

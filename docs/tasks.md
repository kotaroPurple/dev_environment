# 実現タスク一覧

## フェーズ1: 環境と基盤整備
- [x] uv プロジェクトの初期化と依存 (numpy, pydantic など最低限) の追加
- [x] Ruff 設定ファイルの作成 (`E`, `F`, `W`, `I` 有効・行長 100・関数間 2 行)
- [x] 逐次処理設計の README またはクイックスタートドラフト作成

## フェーズ2: データモデル実装
- [x] `BaseTimeSeries` dataclass の作成 (サンプリング周波数、タイムスタンプ、メタ情報)
- [x] ブロック単位のバッファ管理を行う `BlockBuffer` の実装とテスト
- [x] 組み込み向けの軽量 `collate_block` ユーティリティ実装

## フェーズ3: Dataset / DataLoader
- [x] `StreamDataset` 抽象クラスの定義 (`__len__`, `__getitem__`, `stream`)
- [x] `DataSourceAdapter` インターフェースとサンプル (ファイル/モック) 実装
- [x] `StreamDataLoader` の逐次ブロック供給ロジック実装 (停止条件・再開位置・エラーハンドリング)
- [ ] ブロック完了後にのみ次ブロックを読み込む制御のユニットテスト

## フェーズ4: パイプライン層
- [x] `ProcessingNode` 抽象クラスの定義と基本ノード (例: 正規化) 実装
- [x] 依存解決・順序決定を行う `PipelineBuilder` の作成
- [x] 実行制御を担う `PipelineOrchestrator` 実装 (ブロック完了待ち → 次ブロック要求)
- [x] 代表的なノードを組み合わせたサンプルパイプラインと動作確認スクリプト

## フェーズ5: エラー処理と監視
- [x] 例外伝播とポリシー (停止/継続) 選択ロジックの実装
- [x] 処理時間・ブロック番号などのログ出力基盤整備
- [x] メトリクスやデバッグ用情報の取得 API 作成

## フェーズ6: テストと検証
- [x] ユニットテスト整備 (データモデル、データセット/ローダ、ノード、オーケストレータ)
- [x] 結合テストでシリアルなブロック処理フローを検証
- [ ] ベンチマーク/プロファイルで 1 ブロックの遅延測定とボトルネック分析

## フェーズ7: ドキュメントとサンプル
- [x] 開発者向けガイド (設定方法、主要クラスの使い方) 作成
- [x] 組み込み想定の利用例コードと説明
- [x] 今後の並列化拡張に向けた検討メモ (制約・必要な変更点)
